// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "BasicDataType.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Time = _0RL_tc_RTC_mTime;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Time = _0RL_tc_RTC_mTime;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_short_tc()}
};

#ifdef _0RL_tc_RTC_mTimedState
#  undef _0RL_tc_RTC_mTimedState
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedState = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedState:1.0", "TimedState", _0RL_structmember_RTC_mTimedState, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedState = _0RL_tc_RTC_mTimedState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedState = _0RL_tc_RTC_mTimedState;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedShort[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_short_tc()}
};

#ifdef _0RL_tc_RTC_mTimedShort
#  undef _0RL_tc_RTC_mTimedShort
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedShort = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedShort:1.0", "TimedShort", _0RL_structmember_RTC_mTimedShort, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedShort = _0RL_tc_RTC_mTimedShort;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedShort = _0RL_tc_RTC_mTimedShort;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedLong[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_RTC_mTimedLong
#  undef _0RL_tc_RTC_mTimedLong
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedLong = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedLong:1.0", "TimedLong", _0RL_structmember_RTC_mTimedLong, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedLong = _0RL_tc_RTC_mTimedLong;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedLong = _0RL_tc_RTC_mTimedLong;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedUShort[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_ushort_tc()}
};

#ifdef _0RL_tc_RTC_mTimedUShort
#  undef _0RL_tc_RTC_mTimedUShort
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedUShort = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedUShort:1.0", "TimedUShort", _0RL_structmember_RTC_mTimedUShort, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedUShort = _0RL_tc_RTC_mTimedUShort;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedUShort = _0RL_tc_RTC_mTimedUShort;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedULong[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTimedULong
#  undef _0RL_tc_RTC_mTimedULong
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedULong = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedULong:1.0", "TimedULong", _0RL_structmember_RTC_mTimedULong, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedULong = _0RL_tc_RTC_mTimedULong;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedULong = _0RL_tc_RTC_mTimedULong;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedFloat[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_RTC_mTimedFloat
#  undef _0RL_tc_RTC_mTimedFloat
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedFloat = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedFloat:1.0", "TimedFloat", _0RL_structmember_RTC_mTimedFloat, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedFloat = _0RL_tc_RTC_mTimedFloat;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedFloat = _0RL_tc_RTC_mTimedFloat;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedDouble[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedDouble
#  undef _0RL_tc_RTC_mTimedDouble
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedDouble = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedDouble:1.0", "TimedDouble", _0RL_structmember_RTC_mTimedDouble, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedDouble = _0RL_tc_RTC_mTimedDouble;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedDouble = _0RL_tc_RTC_mTimedDouble;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedChar[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_char_tc()}
};

#ifdef _0RL_tc_RTC_mTimedChar
#  undef _0RL_tc_RTC_mTimedChar
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedChar = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedChar:1.0", "TimedChar", _0RL_structmember_RTC_mTimedChar, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedChar = _0RL_tc_RTC_mTimedChar;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedChar = _0RL_tc_RTC_mTimedChar;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedWChar[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_wchar_tc()}
};

#ifdef _0RL_tc_RTC_mTimedWChar
#  undef _0RL_tc_RTC_mTimedWChar
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedWChar = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedWChar:1.0", "TimedWChar", _0RL_structmember_RTC_mTimedWChar, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedWChar = _0RL_tc_RTC_mTimedWChar;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedWChar = _0RL_tc_RTC_mTimedWChar;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedBoolean[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_RTC_mTimedBoolean
#  undef _0RL_tc_RTC_mTimedBoolean
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedBoolean = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedBoolean:1.0", "TimedBoolean", _0RL_structmember_RTC_mTimedBoolean, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedBoolean = _0RL_tc_RTC_mTimedBoolean;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedBoolean = _0RL_tc_RTC_mTimedBoolean;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedOctet[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_octet_tc()}
};

#ifdef _0RL_tc_RTC_mTimedOctet
#  undef _0RL_tc_RTC_mTimedOctet
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedOctet = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedOctet:1.0", "TimedOctet", _0RL_structmember_RTC_mTimedOctet, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedOctet = _0RL_tc_RTC_mTimedOctet;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedOctet = _0RL_tc_RTC_mTimedOctet;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedString[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedString
#  undef _0RL_tc_RTC_mTimedString
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedString = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedString:1.0", "TimedString", _0RL_structmember_RTC_mTimedString, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedString = _0RL_tc_RTC_mTimedString;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedString = _0RL_tc_RTC_mTimedString;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedWString[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_wstring_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedWString
#  undef _0RL_tc_RTC_mTimedWString
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedWString = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedWString:1.0", "TimedWString", _0RL_structmember_RTC_mTimedWString, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedWString = _0RL_tc_RTC_mTimedWString;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedWString = _0RL_tc_RTC_mTimedWString;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedShortSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedShortSeq
#  undef _0RL_tc_RTC_mTimedShortSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedShortSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedShortSeq:1.0", "TimedShortSeq", _0RL_structmember_RTC_mTimedShortSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedShortSeq = _0RL_tc_RTC_mTimedShortSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedShortSeq = _0RL_tc_RTC_mTimedShortSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedLongSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedLongSeq
#  undef _0RL_tc_RTC_mTimedLongSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedLongSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedLongSeq:1.0", "TimedLongSeq", _0RL_structmember_RTC_mTimedLongSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedLongSeq = _0RL_tc_RTC_mTimedLongSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedLongSeq = _0RL_tc_RTC_mTimedLongSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedUShortSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ushort_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedUShortSeq
#  undef _0RL_tc_RTC_mTimedUShortSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedUShortSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedUShortSeq:1.0", "TimedUShortSeq", _0RL_structmember_RTC_mTimedUShortSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedUShortSeq = _0RL_tc_RTC_mTimedUShortSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedUShortSeq = _0RL_tc_RTC_mTimedUShortSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedULongSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedULongSeq
#  undef _0RL_tc_RTC_mTimedULongSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedULongSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedULongSeq:1.0", "TimedULongSeq", _0RL_structmember_RTC_mTimedULongSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedULongSeq = _0RL_tc_RTC_mTimedULongSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedULongSeq = _0RL_tc_RTC_mTimedULongSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedFloatSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_float_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedFloatSeq
#  undef _0RL_tc_RTC_mTimedFloatSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedFloatSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedFloatSeq:1.0", "TimedFloatSeq", _0RL_structmember_RTC_mTimedFloatSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedFloatSeq = _0RL_tc_RTC_mTimedFloatSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedFloatSeq = _0RL_tc_RTC_mTimedFloatSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedDoubleSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedDoubleSeq
#  undef _0RL_tc_RTC_mTimedDoubleSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedDoubleSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedDoubleSeq:1.0", "TimedDoubleSeq", _0RL_structmember_RTC_mTimedDoubleSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedDoubleSeq = _0RL_tc_RTC_mTimedDoubleSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedDoubleSeq = _0RL_tc_RTC_mTimedDoubleSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedCharSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedCharSeq
#  undef _0RL_tc_RTC_mTimedCharSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedCharSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedCharSeq:1.0", "TimedCharSeq", _0RL_structmember_RTC_mTimedCharSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedCharSeq = _0RL_tc_RTC_mTimedCharSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedCharSeq = _0RL_tc_RTC_mTimedCharSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedWCharSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wchar_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedWCharSeq
#  undef _0RL_tc_RTC_mTimedWCharSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedWCharSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedWCharSeq:1.0", "TimedWCharSeq", _0RL_structmember_RTC_mTimedWCharSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedWCharSeq = _0RL_tc_RTC_mTimedWCharSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedWCharSeq = _0RL_tc_RTC_mTimedWCharSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedBooleanSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_boolean_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedBooleanSeq
#  undef _0RL_tc_RTC_mTimedBooleanSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedBooleanSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedBooleanSeq:1.0", "TimedBooleanSeq", _0RL_structmember_RTC_mTimedBooleanSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedBooleanSeq = _0RL_tc_RTC_mTimedBooleanSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedBooleanSeq = _0RL_tc_RTC_mTimedBooleanSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedOctetSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedOctetSeq
#  undef _0RL_tc_RTC_mTimedOctetSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedOctetSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedOctetSeq:1.0", "TimedOctetSeq", _0RL_structmember_RTC_mTimedOctetSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedOctetSeq = _0RL_tc_RTC_mTimedOctetSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedOctetSeq = _0RL_tc_RTC_mTimedOctetSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedStringSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedStringSeq
#  undef _0RL_tc_RTC_mTimedStringSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedStringSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedStringSeq:1.0", "TimedStringSeq", _0RL_structmember_RTC_mTimedStringSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedStringSeq = _0RL_tc_RTC_mTimedStringSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedStringSeq = _0RL_tc_RTC_mTimedStringSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedWStringSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wstring_tc(0, &_0RL_tcTrack), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedWStringSeq
#  undef _0RL_tc_RTC_mTimedWStringSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedWStringSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedWStringSeq:1.0", "TimedWStringSeq", _0RL_structmember_RTC_mTimedWStringSeq, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedWStringSeq = _0RL_tc_RTC_mTimedWStringSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedWStringSeq = _0RL_tc_RTC_mTimedWStringSeq;
#endif


static void _0RL_RTC_mTime_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Time* _p = (RTC::Time*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTime_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Time* _p = new RTC::Time;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTime_destructor_fn(void* _v)
{
  RTC::Time* _p = (RTC::Time*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Time& _s)
{
  RTC::Time* _p = new RTC::Time(_s);
  _a.PR_insert(_0RL_tc_RTC_mTime,
               _0RL_RTC_mTime_marshal_fn,
               _0RL_RTC_mTime_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Time* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTime,
               _0RL_RTC_mTime_marshal_fn,
               _0RL_RTC_mTime_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Time*& _sp)
{
  return _a >>= (const RTC::Time*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Time*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTime,
                    _0RL_RTC_mTime_unmarshal_fn,
                    _0RL_RTC_mTime_marshal_fn,
                    _0RL_RTC_mTime_destructor_fn,
                    _v)) {
    _sp = (const RTC::Time*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedState* _p = (RTC::TimedState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedState* _p = new RTC::TimedState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedState_destructor_fn(void* _v)
{
  RTC::TimedState* _p = (RTC::TimedState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedState& _s)
{
  RTC::TimedState* _p = new RTC::TimedState(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedState,
               _0RL_RTC_mTimedState_marshal_fn,
               _0RL_RTC_mTimedState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedState* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedState,
               _0RL_RTC_mTimedState_marshal_fn,
               _0RL_RTC_mTimedState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedState*& _sp)
{
  return _a >>= (const RTC::TimedState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedState,
                    _0RL_RTC_mTimedState_unmarshal_fn,
                    _0RL_RTC_mTimedState_marshal_fn,
                    _0RL_RTC_mTimedState_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedShort_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedShort* _p = (RTC::TimedShort*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedShort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedShort* _p = new RTC::TimedShort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedShort_destructor_fn(void* _v)
{
  RTC::TimedShort* _p = (RTC::TimedShort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedShort& _s)
{
  RTC::TimedShort* _p = new RTC::TimedShort(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedShort,
               _0RL_RTC_mTimedShort_marshal_fn,
               _0RL_RTC_mTimedShort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedShort* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedShort,
               _0RL_RTC_mTimedShort_marshal_fn,
               _0RL_RTC_mTimedShort_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedShort*& _sp)
{
  return _a >>= (const RTC::TimedShort*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedShort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedShort,
                    _0RL_RTC_mTimedShort_unmarshal_fn,
                    _0RL_RTC_mTimedShort_marshal_fn,
                    _0RL_RTC_mTimedShort_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedShort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedLong_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedLong* _p = (RTC::TimedLong*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedLong_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedLong* _p = new RTC::TimedLong;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedLong_destructor_fn(void* _v)
{
  RTC::TimedLong* _p = (RTC::TimedLong*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedLong& _s)
{
  RTC::TimedLong* _p = new RTC::TimedLong(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedLong,
               _0RL_RTC_mTimedLong_marshal_fn,
               _0RL_RTC_mTimedLong_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedLong* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedLong,
               _0RL_RTC_mTimedLong_marshal_fn,
               _0RL_RTC_mTimedLong_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedLong*& _sp)
{
  return _a >>= (const RTC::TimedLong*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedLong*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedLong,
                    _0RL_RTC_mTimedLong_unmarshal_fn,
                    _0RL_RTC_mTimedLong_marshal_fn,
                    _0RL_RTC_mTimedLong_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedLong*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedUShort_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedUShort* _p = (RTC::TimedUShort*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedUShort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedUShort* _p = new RTC::TimedUShort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedUShort_destructor_fn(void* _v)
{
  RTC::TimedUShort* _p = (RTC::TimedUShort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedUShort& _s)
{
  RTC::TimedUShort* _p = new RTC::TimedUShort(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedUShort,
               _0RL_RTC_mTimedUShort_marshal_fn,
               _0RL_RTC_mTimedUShort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedUShort* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedUShort,
               _0RL_RTC_mTimedUShort_marshal_fn,
               _0RL_RTC_mTimedUShort_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedUShort*& _sp)
{
  return _a >>= (const RTC::TimedUShort*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedUShort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedUShort,
                    _0RL_RTC_mTimedUShort_unmarshal_fn,
                    _0RL_RTC_mTimedUShort_marshal_fn,
                    _0RL_RTC_mTimedUShort_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedUShort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedULong_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedULong* _p = (RTC::TimedULong*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedULong_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedULong* _p = new RTC::TimedULong;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedULong_destructor_fn(void* _v)
{
  RTC::TimedULong* _p = (RTC::TimedULong*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedULong& _s)
{
  RTC::TimedULong* _p = new RTC::TimedULong(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedULong,
               _0RL_RTC_mTimedULong_marshal_fn,
               _0RL_RTC_mTimedULong_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedULong* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedULong,
               _0RL_RTC_mTimedULong_marshal_fn,
               _0RL_RTC_mTimedULong_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedULong*& _sp)
{
  return _a >>= (const RTC::TimedULong*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedULong*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedULong,
                    _0RL_RTC_mTimedULong_unmarshal_fn,
                    _0RL_RTC_mTimedULong_marshal_fn,
                    _0RL_RTC_mTimedULong_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedULong*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedFloat_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedFloat* _p = (RTC::TimedFloat*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedFloat_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedFloat* _p = new RTC::TimedFloat;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedFloat_destructor_fn(void* _v)
{
  RTC::TimedFloat* _p = (RTC::TimedFloat*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedFloat& _s)
{
  RTC::TimedFloat* _p = new RTC::TimedFloat(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedFloat,
               _0RL_RTC_mTimedFloat_marshal_fn,
               _0RL_RTC_mTimedFloat_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedFloat* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedFloat,
               _0RL_RTC_mTimedFloat_marshal_fn,
               _0RL_RTC_mTimedFloat_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedFloat*& _sp)
{
  return _a >>= (const RTC::TimedFloat*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedFloat*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedFloat,
                    _0RL_RTC_mTimedFloat_unmarshal_fn,
                    _0RL_RTC_mTimedFloat_marshal_fn,
                    _0RL_RTC_mTimedFloat_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedFloat*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedDouble_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedDouble* _p = (RTC::TimedDouble*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedDouble_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedDouble* _p = new RTC::TimedDouble;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedDouble_destructor_fn(void* _v)
{
  RTC::TimedDouble* _p = (RTC::TimedDouble*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedDouble& _s)
{
  RTC::TimedDouble* _p = new RTC::TimedDouble(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedDouble,
               _0RL_RTC_mTimedDouble_marshal_fn,
               _0RL_RTC_mTimedDouble_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedDouble* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedDouble,
               _0RL_RTC_mTimedDouble_marshal_fn,
               _0RL_RTC_mTimedDouble_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedDouble*& _sp)
{
  return _a >>= (const RTC::TimedDouble*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedDouble*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedDouble,
                    _0RL_RTC_mTimedDouble_unmarshal_fn,
                    _0RL_RTC_mTimedDouble_marshal_fn,
                    _0RL_RTC_mTimedDouble_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedDouble*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedChar_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedChar* _p = (RTC::TimedChar*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedChar_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedChar* _p = new RTC::TimedChar;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedChar_destructor_fn(void* _v)
{
  RTC::TimedChar* _p = (RTC::TimedChar*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedChar& _s)
{
  RTC::TimedChar* _p = new RTC::TimedChar(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedChar,
               _0RL_RTC_mTimedChar_marshal_fn,
               _0RL_RTC_mTimedChar_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedChar* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedChar,
               _0RL_RTC_mTimedChar_marshal_fn,
               _0RL_RTC_mTimedChar_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedChar*& _sp)
{
  return _a >>= (const RTC::TimedChar*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedChar*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedChar,
                    _0RL_RTC_mTimedChar_unmarshal_fn,
                    _0RL_RTC_mTimedChar_marshal_fn,
                    _0RL_RTC_mTimedChar_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedChar*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedWChar_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedWChar* _p = (RTC::TimedWChar*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedWChar_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedWChar* _p = new RTC::TimedWChar;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedWChar_destructor_fn(void* _v)
{
  RTC::TimedWChar* _p = (RTC::TimedWChar*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedWChar& _s)
{
  RTC::TimedWChar* _p = new RTC::TimedWChar(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedWChar,
               _0RL_RTC_mTimedWChar_marshal_fn,
               _0RL_RTC_mTimedWChar_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedWChar* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedWChar,
               _0RL_RTC_mTimedWChar_marshal_fn,
               _0RL_RTC_mTimedWChar_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedWChar*& _sp)
{
  return _a >>= (const RTC::TimedWChar*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedWChar*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedWChar,
                    _0RL_RTC_mTimedWChar_unmarshal_fn,
                    _0RL_RTC_mTimedWChar_marshal_fn,
                    _0RL_RTC_mTimedWChar_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedWChar*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedBoolean_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedBoolean* _p = (RTC::TimedBoolean*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedBoolean_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedBoolean* _p = new RTC::TimedBoolean;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedBoolean_destructor_fn(void* _v)
{
  RTC::TimedBoolean* _p = (RTC::TimedBoolean*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedBoolean& _s)
{
  RTC::TimedBoolean* _p = new RTC::TimedBoolean(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedBoolean,
               _0RL_RTC_mTimedBoolean_marshal_fn,
               _0RL_RTC_mTimedBoolean_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedBoolean* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedBoolean,
               _0RL_RTC_mTimedBoolean_marshal_fn,
               _0RL_RTC_mTimedBoolean_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedBoolean*& _sp)
{
  return _a >>= (const RTC::TimedBoolean*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedBoolean*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedBoolean,
                    _0RL_RTC_mTimedBoolean_unmarshal_fn,
                    _0RL_RTC_mTimedBoolean_marshal_fn,
                    _0RL_RTC_mTimedBoolean_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedBoolean*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedOctet_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedOctet* _p = (RTC::TimedOctet*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedOctet_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedOctet* _p = new RTC::TimedOctet;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedOctet_destructor_fn(void* _v)
{
  RTC::TimedOctet* _p = (RTC::TimedOctet*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedOctet& _s)
{
  RTC::TimedOctet* _p = new RTC::TimedOctet(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedOctet,
               _0RL_RTC_mTimedOctet_marshal_fn,
               _0RL_RTC_mTimedOctet_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedOctet* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedOctet,
               _0RL_RTC_mTimedOctet_marshal_fn,
               _0RL_RTC_mTimedOctet_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedOctet*& _sp)
{
  return _a >>= (const RTC::TimedOctet*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedOctet*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedOctet,
                    _0RL_RTC_mTimedOctet_unmarshal_fn,
                    _0RL_RTC_mTimedOctet_marshal_fn,
                    _0RL_RTC_mTimedOctet_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedOctet*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedString_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedString* _p = (RTC::TimedString*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedString_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedString* _p = new RTC::TimedString;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedString_destructor_fn(void* _v)
{
  RTC::TimedString* _p = (RTC::TimedString*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedString& _s)
{
  RTC::TimedString* _p = new RTC::TimedString(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedString,
               _0RL_RTC_mTimedString_marshal_fn,
               _0RL_RTC_mTimedString_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedString* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedString,
               _0RL_RTC_mTimedString_marshal_fn,
               _0RL_RTC_mTimedString_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedString*& _sp)
{
  return _a >>= (const RTC::TimedString*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedString*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedString,
                    _0RL_RTC_mTimedString_unmarshal_fn,
                    _0RL_RTC_mTimedString_marshal_fn,
                    _0RL_RTC_mTimedString_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedString*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedWString_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedWString* _p = (RTC::TimedWString*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedWString_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedWString* _p = new RTC::TimedWString;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedWString_destructor_fn(void* _v)
{
  RTC::TimedWString* _p = (RTC::TimedWString*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedWString& _s)
{
  RTC::TimedWString* _p = new RTC::TimedWString(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedWString,
               _0RL_RTC_mTimedWString_marshal_fn,
               _0RL_RTC_mTimedWString_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedWString* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedWString,
               _0RL_RTC_mTimedWString_marshal_fn,
               _0RL_RTC_mTimedWString_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedWString*& _sp)
{
  return _a >>= (const RTC::TimedWString*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedWString*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedWString,
                    _0RL_RTC_mTimedWString_unmarshal_fn,
                    _0RL_RTC_mTimedWString_marshal_fn,
                    _0RL_RTC_mTimedWString_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedWString*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedShortSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedShortSeq* _p = (RTC::TimedShortSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedShortSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedShortSeq* _p = new RTC::TimedShortSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedShortSeq_destructor_fn(void* _v)
{
  RTC::TimedShortSeq* _p = (RTC::TimedShortSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedShortSeq& _s)
{
  RTC::TimedShortSeq* _p = new RTC::TimedShortSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedShortSeq,
               _0RL_RTC_mTimedShortSeq_marshal_fn,
               _0RL_RTC_mTimedShortSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedShortSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedShortSeq,
               _0RL_RTC_mTimedShortSeq_marshal_fn,
               _0RL_RTC_mTimedShortSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedShortSeq*& _sp)
{
  return _a >>= (const RTC::TimedShortSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedShortSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedShortSeq,
                    _0RL_RTC_mTimedShortSeq_unmarshal_fn,
                    _0RL_RTC_mTimedShortSeq_marshal_fn,
                    _0RL_RTC_mTimedShortSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedShortSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedLongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedLongSeq* _p = (RTC::TimedLongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedLongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedLongSeq* _p = new RTC::TimedLongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedLongSeq_destructor_fn(void* _v)
{
  RTC::TimedLongSeq* _p = (RTC::TimedLongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedLongSeq& _s)
{
  RTC::TimedLongSeq* _p = new RTC::TimedLongSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedLongSeq,
               _0RL_RTC_mTimedLongSeq_marshal_fn,
               _0RL_RTC_mTimedLongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedLongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedLongSeq,
               _0RL_RTC_mTimedLongSeq_marshal_fn,
               _0RL_RTC_mTimedLongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedLongSeq*& _sp)
{
  return _a >>= (const RTC::TimedLongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedLongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedLongSeq,
                    _0RL_RTC_mTimedLongSeq_unmarshal_fn,
                    _0RL_RTC_mTimedLongSeq_marshal_fn,
                    _0RL_RTC_mTimedLongSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedLongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedUShortSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedUShortSeq* _p = (RTC::TimedUShortSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedUShortSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedUShortSeq* _p = new RTC::TimedUShortSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedUShortSeq_destructor_fn(void* _v)
{
  RTC::TimedUShortSeq* _p = (RTC::TimedUShortSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedUShortSeq& _s)
{
  RTC::TimedUShortSeq* _p = new RTC::TimedUShortSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedUShortSeq,
               _0RL_RTC_mTimedUShortSeq_marshal_fn,
               _0RL_RTC_mTimedUShortSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedUShortSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedUShortSeq,
               _0RL_RTC_mTimedUShortSeq_marshal_fn,
               _0RL_RTC_mTimedUShortSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedUShortSeq*& _sp)
{
  return _a >>= (const RTC::TimedUShortSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedUShortSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedUShortSeq,
                    _0RL_RTC_mTimedUShortSeq_unmarshal_fn,
                    _0RL_RTC_mTimedUShortSeq_marshal_fn,
                    _0RL_RTC_mTimedUShortSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedUShortSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedULongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedULongSeq* _p = (RTC::TimedULongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedULongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedULongSeq* _p = new RTC::TimedULongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedULongSeq_destructor_fn(void* _v)
{
  RTC::TimedULongSeq* _p = (RTC::TimedULongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedULongSeq& _s)
{
  RTC::TimedULongSeq* _p = new RTC::TimedULongSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedULongSeq,
               _0RL_RTC_mTimedULongSeq_marshal_fn,
               _0RL_RTC_mTimedULongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedULongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedULongSeq,
               _0RL_RTC_mTimedULongSeq_marshal_fn,
               _0RL_RTC_mTimedULongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedULongSeq*& _sp)
{
  return _a >>= (const RTC::TimedULongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedULongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedULongSeq,
                    _0RL_RTC_mTimedULongSeq_unmarshal_fn,
                    _0RL_RTC_mTimedULongSeq_marshal_fn,
                    _0RL_RTC_mTimedULongSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedULongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedFloatSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedFloatSeq* _p = (RTC::TimedFloatSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedFloatSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedFloatSeq* _p = new RTC::TimedFloatSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedFloatSeq_destructor_fn(void* _v)
{
  RTC::TimedFloatSeq* _p = (RTC::TimedFloatSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedFloatSeq& _s)
{
  RTC::TimedFloatSeq* _p = new RTC::TimedFloatSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedFloatSeq,
               _0RL_RTC_mTimedFloatSeq_marshal_fn,
               _0RL_RTC_mTimedFloatSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedFloatSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedFloatSeq,
               _0RL_RTC_mTimedFloatSeq_marshal_fn,
               _0RL_RTC_mTimedFloatSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedFloatSeq*& _sp)
{
  return _a >>= (const RTC::TimedFloatSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedFloatSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedFloatSeq,
                    _0RL_RTC_mTimedFloatSeq_unmarshal_fn,
                    _0RL_RTC_mTimedFloatSeq_marshal_fn,
                    _0RL_RTC_mTimedFloatSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedFloatSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedDoubleSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedDoubleSeq* _p = (RTC::TimedDoubleSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedDoubleSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedDoubleSeq* _p = new RTC::TimedDoubleSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedDoubleSeq_destructor_fn(void* _v)
{
  RTC::TimedDoubleSeq* _p = (RTC::TimedDoubleSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedDoubleSeq& _s)
{
  RTC::TimedDoubleSeq* _p = new RTC::TimedDoubleSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedDoubleSeq,
               _0RL_RTC_mTimedDoubleSeq_marshal_fn,
               _0RL_RTC_mTimedDoubleSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedDoubleSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedDoubleSeq,
               _0RL_RTC_mTimedDoubleSeq_marshal_fn,
               _0RL_RTC_mTimedDoubleSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedDoubleSeq*& _sp)
{
  return _a >>= (const RTC::TimedDoubleSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedDoubleSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedDoubleSeq,
                    _0RL_RTC_mTimedDoubleSeq_unmarshal_fn,
                    _0RL_RTC_mTimedDoubleSeq_marshal_fn,
                    _0RL_RTC_mTimedDoubleSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedDoubleSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedCharSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedCharSeq* _p = (RTC::TimedCharSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedCharSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedCharSeq* _p = new RTC::TimedCharSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedCharSeq_destructor_fn(void* _v)
{
  RTC::TimedCharSeq* _p = (RTC::TimedCharSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedCharSeq& _s)
{
  RTC::TimedCharSeq* _p = new RTC::TimedCharSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedCharSeq,
               _0RL_RTC_mTimedCharSeq_marshal_fn,
               _0RL_RTC_mTimedCharSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedCharSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedCharSeq,
               _0RL_RTC_mTimedCharSeq_marshal_fn,
               _0RL_RTC_mTimedCharSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedCharSeq*& _sp)
{
  return _a >>= (const RTC::TimedCharSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedCharSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedCharSeq,
                    _0RL_RTC_mTimedCharSeq_unmarshal_fn,
                    _0RL_RTC_mTimedCharSeq_marshal_fn,
                    _0RL_RTC_mTimedCharSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedCharSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedWCharSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedWCharSeq* _p = (RTC::TimedWCharSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedWCharSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedWCharSeq* _p = new RTC::TimedWCharSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedWCharSeq_destructor_fn(void* _v)
{
  RTC::TimedWCharSeq* _p = (RTC::TimedWCharSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedWCharSeq& _s)
{
  RTC::TimedWCharSeq* _p = new RTC::TimedWCharSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedWCharSeq,
               _0RL_RTC_mTimedWCharSeq_marshal_fn,
               _0RL_RTC_mTimedWCharSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedWCharSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedWCharSeq,
               _0RL_RTC_mTimedWCharSeq_marshal_fn,
               _0RL_RTC_mTimedWCharSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedWCharSeq*& _sp)
{
  return _a >>= (const RTC::TimedWCharSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedWCharSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedWCharSeq,
                    _0RL_RTC_mTimedWCharSeq_unmarshal_fn,
                    _0RL_RTC_mTimedWCharSeq_marshal_fn,
                    _0RL_RTC_mTimedWCharSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedWCharSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedBooleanSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedBooleanSeq* _p = (RTC::TimedBooleanSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedBooleanSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedBooleanSeq* _p = new RTC::TimedBooleanSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedBooleanSeq_destructor_fn(void* _v)
{
  RTC::TimedBooleanSeq* _p = (RTC::TimedBooleanSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedBooleanSeq& _s)
{
  RTC::TimedBooleanSeq* _p = new RTC::TimedBooleanSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedBooleanSeq,
               _0RL_RTC_mTimedBooleanSeq_marshal_fn,
               _0RL_RTC_mTimedBooleanSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedBooleanSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedBooleanSeq,
               _0RL_RTC_mTimedBooleanSeq_marshal_fn,
               _0RL_RTC_mTimedBooleanSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedBooleanSeq*& _sp)
{
  return _a >>= (const RTC::TimedBooleanSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedBooleanSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedBooleanSeq,
                    _0RL_RTC_mTimedBooleanSeq_unmarshal_fn,
                    _0RL_RTC_mTimedBooleanSeq_marshal_fn,
                    _0RL_RTC_mTimedBooleanSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedBooleanSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedOctetSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedOctetSeq* _p = (RTC::TimedOctetSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedOctetSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedOctetSeq* _p = new RTC::TimedOctetSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedOctetSeq_destructor_fn(void* _v)
{
  RTC::TimedOctetSeq* _p = (RTC::TimedOctetSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedOctetSeq& _s)
{
  RTC::TimedOctetSeq* _p = new RTC::TimedOctetSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedOctetSeq,
               _0RL_RTC_mTimedOctetSeq_marshal_fn,
               _0RL_RTC_mTimedOctetSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedOctetSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedOctetSeq,
               _0RL_RTC_mTimedOctetSeq_marshal_fn,
               _0RL_RTC_mTimedOctetSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedOctetSeq*& _sp)
{
  return _a >>= (const RTC::TimedOctetSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedOctetSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedOctetSeq,
                    _0RL_RTC_mTimedOctetSeq_unmarshal_fn,
                    _0RL_RTC_mTimedOctetSeq_marshal_fn,
                    _0RL_RTC_mTimedOctetSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedOctetSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedStringSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedStringSeq* _p = (RTC::TimedStringSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedStringSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedStringSeq* _p = new RTC::TimedStringSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedStringSeq_destructor_fn(void* _v)
{
  RTC::TimedStringSeq* _p = (RTC::TimedStringSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedStringSeq& _s)
{
  RTC::TimedStringSeq* _p = new RTC::TimedStringSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedStringSeq,
               _0RL_RTC_mTimedStringSeq_marshal_fn,
               _0RL_RTC_mTimedStringSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedStringSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedStringSeq,
               _0RL_RTC_mTimedStringSeq_marshal_fn,
               _0RL_RTC_mTimedStringSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedStringSeq*& _sp)
{
  return _a >>= (const RTC::TimedStringSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedStringSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedStringSeq,
                    _0RL_RTC_mTimedStringSeq_unmarshal_fn,
                    _0RL_RTC_mTimedStringSeq_marshal_fn,
                    _0RL_RTC_mTimedStringSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedStringSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedWStringSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedWStringSeq* _p = (RTC::TimedWStringSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedWStringSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedWStringSeq* _p = new RTC::TimedWStringSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedWStringSeq_destructor_fn(void* _v)
{
  RTC::TimedWStringSeq* _p = (RTC::TimedWStringSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedWStringSeq& _s)
{
  RTC::TimedWStringSeq* _p = new RTC::TimedWStringSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedWStringSeq,
               _0RL_RTC_mTimedWStringSeq_marshal_fn,
               _0RL_RTC_mTimedWStringSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedWStringSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedWStringSeq,
               _0RL_RTC_mTimedWStringSeq_marshal_fn,
               _0RL_RTC_mTimedWStringSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedWStringSeq*& _sp)
{
  return _a >>= (const RTC::TimedWStringSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedWStringSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedWStringSeq,
                    _0RL_RTC_mTimedWStringSeq_unmarshal_fn,
                    _0RL_RTC_mTimedWStringSeq_marshal_fn,
                    _0RL_RTC_mTimedWStringSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedWStringSeq*)_v;
    return 1;
  }
  return 0;
}

